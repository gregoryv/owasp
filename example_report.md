# Report ISVS
## Summary

- L1: 1/8 applicable (total 64)
- L2: 1/7 applicable (total 114)
- L3: 1/7 applicable (total 123)

## Applicable
- [x] **1.1.1** Verify that all applications in the IoT ecosystem are developed with a level of security that is in line with the security criticality of the application.
- [ ] **1.1.2** Verify that all components and communication channels in the IoT application's ecosystem have been identified and are known to be needed. Remove or disable any that aren't necessary.
- [ ] **1.1.3** Verify that sensitive information and security critical actions have been identified and documented.
- [ ] **1.1.4** Verify that the location where sensitive data is stored in the ecosystem is clearly identified and separated from unprivileged storage locations.
- [ ] **1.1.5** Verify that security controls are enforced server-side and that data and instructions are not blindly trusted by server-side components.
- [ ] **1.1.6** Verify that a responsible disclosure policy has been established and that it is easily found on the company website. Ensure that the policy provides a clear overview on how vulnerabilities can be communicated securely and how they'll be followed up on.
- [ ] **1.1.7** Verify that users and relevant stakeholders are notified when vulnerabilities are identified through established communication channels (website, e-mail ...).
- [ ] **1.3.1** Verify that each application in the ecosystem is built using a secure and repeatable build environment.

## Not Applicable
- 1.2.1 Verify that each application (including firmware) in the ecosystem maintains a s...
- 1.2.2 Verify that potential areas of risk that come with the use of third-party and op...
- 1.2.3 Verify the device is released with firmware and configuration appropriate for a ...
- 1.2.4 Verify that access to debugging interfaces (e.g. JTAG, SWD) is disabled or prote...
- 1.2.5 Verify debug capabilities in FPGAs are disabled.
- 1.2.6 Verify that devices are provisioned with a cryptographic root of trust that is h...
- 1.2.7 Verify that code integrity protection mechanisms are enabled and locked in hardw...
- 1.2.8 Verify third-party code and components are analyzed using static analysis tools ...
- 1.2.9 Verify debug paths and traces are depopulated from production PCBs.
- 1.3.2 Verify GPL based firmware has its source code published and that no sensitive or...
- 1.3.3 Verify that use of banned C/C++ functions (i.e. memcpy, strcpy, etc.) are replac...
- 1.3.4 Verify packages are downloaded and built from trusted sources.
- 1.3.5 Verify build pipelines only perform builds of source code maintained in version ...
- 1.3.6 Verify that compilers, version control clients, development utilities, and softw...
- 1.3.7 Verify packages are compiled with Object Size Checking (OSC). e.g. -D_FORTIFY_SO...
- 1.3.8 Verify packages are compiled with No eXecute (NX) or Data Execution Protection (...
- 1.3.9 Verify packages are compiled with Position Independent Executable (PIE). e.g. -f...
- 1.3.10 Verify packages are compiled with Stack Smashing Protector (SSP). e.g. -fstack-p...
- 1.3.11 Verify packages are compiled with read-only relocation (RELRO). e.g. -Wl,-z,relr...
- 1.3.12 Verify release builds do not contain debug code or privileged diagnostic functio...
- 1.3.13 Verify that debug and release firmware images are signed using different keys.
- 1.3.14 Verify that debug information does not contain sensitive information, such as PI...
- 1.3.15 Verify that embedded applications are not susceptible to OS command injection by...
- 2.1.1 Verify that all forms of users and accounts in the IoT ecosystem can be uniquely...
- 2.1.2 Verify that all connected devices within the IoT ecosystem can be uniquely ident...
- 2.1.3 Verify strong user and device authentication is enforced across the IoT ecosyste...
- 2.1.4 Verify that user, services, and device authentication schemes share a common fra...
- 2.1.5 Verify certificate based authentication is preferred over password based authent...
- 2.1.6 Verify good password policies are enforced throughout the IoT ecosystem by disal...
- 2.2.1 Verify that sensitive information such as personal identifiable information (PII...
- 2.2.2 Verify that IoT system accounts across users, services and devices share a commo...
- 2.2.3 Verify that devices enforce the concept of least privilege by limiting applicati...
- 2.2.4 Verify that ownership is validated upon registration and as part of decommission...
- 2.2.5 Verify device debug capabilities can only be accessed by approved staff (e.g. su...
- 2.3.1 Verify that sensitive information such as personal identifiable information (PII...
- 2.3.2 Verify that in case a device is decommissioned, or in case the owner changes, al...
- 2.3.3 Verify that in case a device is decommissioned, or the owner changes, it is mark...
- 2.3.4 Verify that sensitive information maintained in memory is overwritten with zeros...
- 2.4.1 Verify cryptographic secrets are unique per device.
- 2.4.2 Verify proper use of cryptography. Only standard and strong algorithms should be...
- 2.4.3 Verify secure sources of randomness are provided by the operating system and/or ...
- 2.4.4 Verify that cryptographic secrets used by the device are stored securely by leve...
- 2.4.5 Verify that cryptographic primitives used by the device are provided by dedicate...
- 2.4.6 Verify the cryptographic libraries used are certified to be compliant with a rec...
- 3.1.1 Verify that the bootloader does not allow code to be loaded from arbitrary locat...
- 3.1.2 Verify bootloader configurations are immutable in production releases.
- 3.1.3 Verify that communication interfaces such as, USB, UART, and other variants are ...
- 3.1.4 Verify that the authenticity of the first stage bootloader is verified by a trus...
- 3.1.5 Verify that the authenticity of next bootloader stages or application code is cr...
- 3.1.6 Verify that bootloader stages do not contain sensitive information (e.g. private...
- 3.1.7 Verify that firmware is stored in an encrypted volume at rest.
- 3.1.8 Verify that Direct Memory Access (DMA) is not possible during boot. For example,...
- 3.2.1 Verify that the embedded operating system is configured according to industry be...
- 3.2.2 Verify that all network services exposed by the device on every network interfac...
- 3.2.3 Verify that the device does not make use of of legacy or insecure protocols such...
- 3.2.4 Verify that the OS kernel and software components are up to date and do not cont...
- 3.2.5 Verify that persistent filesystem storage volumes are encrypted.
- 3.2.6 Verify that applications running on the device use the security features of the ...
- 3.2.7 Verify that memory protection controls such as Address Space Layout Randomizatio...
- 3.2.8 Verify hardware level memory protection is used and privilege levels are enforce...
- 3.2.9 Verify the embedded OS provides protection against unauthorized access to RAM (e...
- 3.2.10 Verify that an Integrity Measurement Architecture (IMA) is in use and appropriat...
- 3.2.11 Verify that that third-party applications and services are configured to execute...
- 3.3.1 Verify that processes are isolated using Linux kernel namespaces.
- 3.3.2 Verify that critical processes are configured to limit resources using control g...
- 3.3.4 Verify that Linux kernel capabilities are configured with a minimal set for proc...
- 3.3.5 Verify that SECure COMPuting  (seccomp BPF) with filters are used and properly c...
- 3.3.6 Verify the use of kernel security modules such as SELinux, AppArmor, GRSEC, and ...
- 3.4.1 Verify that packages and user space applications use over the air updates decoup...
- 3.4.2 Verify that devices can be updated automatically upon a pre-defined schedule.
- 3.4.3 Verify that the authenticity of updates are cryptographically signed by a truste...
- 3.4.4 Verify that the update process is not vulnerable to time-of-check time-of-use at...
- 3.4.5 Verify that updates do not modify user-configured preferences, security, and/or ...
- 3.4.6 Verify that the device cannot be downgraded to known vulnerable versions (anti-r...
- 3.4.7 Verify that in the event of an update failure, the device reverts to a backup im...
- 3.4.8 Verify that unsigned debug pre-production firmware builds can not be flashed ont...
- 3.4.9 Verify that encrypted firmware images are securely decrypted on the device.
- 3.4.10 Verify that the device authenticates to the update server component prior to dow...
- 3.4.11 Verify that firmware updates are stored encrypted server-side.
- 3.5.1 Verify that encryption is used on the bus between the security chip and other ha...
- 3.5.2 Verify that keys (either secret or private) used to enable encryption on the ser...
- 3.5.3 Verify any default vendor keys used in bus encryption are replaced in production...
- 3.5.4 Verify that deprecated insecure ciphers and hash functions (e.g. 3DES, MD5, SHA1...
- 3.6.1 Verify that loaded kernel modules are cryptographically signed and verified.
- 3.6.2 Verify that only required kernel modules are enabled during runtime.
- 4.1.1 Verify that communication with other components in the IoT ecosystem (including ...
- 4.1.2 Verify that in case TLS is used, that its securely configured with FIPS-based ci...
- 4.1.3 Verify that in case TLS is used, the device cryptographically verifies the X.509...
- 4.1.4 Verify that for availability critical applications, either protection or detecti...
- 4.1.6 Verify that device's TLS implementation uses its own certificate store, pins to ...
- 4.1.7 Verify that inter-chip communication is encrypted (e.g. Main board to daughter b...
- 4.2.1 Verify that unencrypted communication is limited to data and instructions that a...
- 4.2.2 Verify that if shared secrets are used to cryptographically secure communication...
- 4.2.3 Verify MQTT brokers only allow authorized IoT devices to subscribe and publish m...
- 4.2.7 Verify certificates are favored over native username and passwords to authentica...
- 4.3.1 Verify that pairing and discovery is blocked in Bluetooth devices except when ne...
- 4.3.2 Verify that PIN or PassKey codes are not easily guessable. For example, verify P...
- 4.3.3 Verify devices that support for old versions of Bluetooth with simple modes of a...
- 4.3.4 Verify that for modern versions of Bluetooth, at least 6 digits are required for...
- 4.3.5 Verify that encryption keys are the maximum allowable size. Bluetooth has config...
- 4.3.6 Verify the most secure Bluetooth pairing method available is used. Verify Out Of...
- 4.3.7 Verify the strongest Bluetooth Security Mode and Level supported by the device i...
- 4.4.1 Verify Wi-Fi connectivity is disabled unless required as part of device function...
- 4.4.2 Verify that WPA2 or higher is used to protect Wi-Fi communications.
- 4.4.3 Verify that in case WPA is used, it is used with AES encryption (CCMP mode).
- 4.4.4 Verify that Wi-Fi Protected Setup (WPS) is not used to establish Wi-Fi connectio...
- 5.1.1 Verify that the platform supports disabling or protecting access to debugging in...
- 5.1.2 Verify that the platform supports validating the authenticity of the first stage...
- 5.1.3 Verify that cryptographic functions are provided by the platform. e.g. by levera...
- 5.1.4 Verify that sensitive data such as private keys and certificates can be stored s...
- 5.1.5 Verify that the platform provides memory and I/O protection capabilities so that...
- 5.1.6 Verify that the platform security configuration of the platform can be locked. e...
- 5.1.7 Verify that debugging headers are removed from PCBs.
- 5.1.8 Verify the chosen hardware has no unofficially documented debug features, such a...
- 5.1.9 Verify that the platform provides protection against physical decapsulation, sid...
- 5.1.10 Verify descriptive silkscreens are removed from PCBs
